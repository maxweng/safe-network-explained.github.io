---
layout: post
title:  "区块链爱好者 Safe Network 入门指南"
date:   2017-04-12 00:00:00 +0000
updated: 2017-04-12 00:00:00 +0000
categories: bitcoin
---
如果你已经知道比特币的工作方式，下文能够更好地帮助了解SAFE网络，而不需再从头开始理解。

尽管SAFE网络和比特币网络拥有非常相似的目标和结果，但它们工作方式的差异却相当大。如果下面的任何一个解释读起来比较费劲，那是因为比特币的概念只能延伸到描述部分的SAFE网络。相似之处将让我们更方便地理解，但最终还是有局限性。

以下内容不是为了让你获得对SAFE网络的全面了解，而是为进一步阅读SAFE的内容提供一个坚实的基础。每部分的标题就像一间大房子的每一个窗口，让我们得以从比特币的角度来窥视SAFE网络。

## 目录
<ul>
<li><a id="blockchain_toc" href="#区块链" rel="nofollow">区块链</a></li>
<li><a id="proof-of-work-for-verification_toc" href="#proof-of-work-for-verification" rel="nofollow">工作量证明验证</a></li>
<li><a id="双重花费问题预防" href="#双重花费问题预防" rel="nofollow">双重花费问题预防</a></li>
</ul>

### 区块链

区块链是比特币最重要的创新。区块链的目的是为了达成对比特币网络中数据状态的一致性。

SAFE网络与区块链目标解决相同的问题，即共识问题，但并不使用区块链。SAFE网络解决共识问题的重大创新被称为“邻组共识（close group consensus）”。

对于比特币和区块链，其网络上每个节点都有网络所有数据的完整副本。随着新数据不断被添加到网络中，每个节点都需要保留所有数据的副本。

SAFE网络对网络上每份数据只保留几个副本。每份数据由网络分配一组节点（约30个）来确保该份数据的完整性。对于数据的修改只能当对数据的真实状态在该组中达成绝大多数共识（约80％）时才可进行。因为只有相对较少的节点数必须就数据的真实状态达成一致，所以SAFE网络之于比特币要更高效。

有些人可能有这样的疑问，应该是多大的群组才能确保足够的安全性呢？节点为什么不多一些，为什么不少一些？相较于通过证明来推导出这个数字，我们可以花些时间来考虑一下，比特币和SAFE网络的共识规则希望实现的共同目标：数据不应容易丢失，损坏或错误地被修改。如果该组节点可以被人为操纵（被黑客入侵或贿赂等），则他们控制的数据将不被认为是安全的。这个问题就是通过“邻组共识”的“邻组”来解决的。

邻近度算法，是决定管理每份数据的节点群组如何形成的算法。该群组的成员由网络自动选择，所以是非常难以人为操纵的（而且该难度，类似比特币，会根据网络的大小而变化调整，随着网络扩大难度会越来越高）。这里就不再赘诉“邻组共识”算法的细节，相关内容可以参见SAFE网络所使用的xor距离内容以及那里提到的相关资料。

如果直接比较比特币与SAFE网络关于安全性的讲法，比特币是由“工作量证明”来保证安全，而SAFE网络则是通过“邻组共识”来保障的。

想了解更多关于使用邻近群组，而非区块链，的共识算法，可以阅读Maidsafe博客上的关于[共识系统](https://blog.maidsafe.net/tag/consensus-systems/)的内容，以及关于不相交群组[Disjoint Groups](https://github.com/maidsafe/rfcs/blob/master/text/0037-disjoint-groups/0037-disjoint-groups.md).的讨论。

最后强调下，如同区块链是实现比特币的关键创新，邻组共识则是实现SAFE网络提供相同功能但大幅提高效率的关键创新。

[返回目录](#blockchain_toc)

### 工作量证明验证

区块链的一个突破是，很容易验证用户拥有的数据是否真实在链上，而不是某个恶意用户发送的无效数据。可以做到这点，是因为工作量证明很容易验证但却很难创造出来。

那么SAFE网络是如何确保用户收到的数据是来自“真实”的SAFE网络，而不是来自某个恶意用户所伪造的网络呢？

这里共有两个主要的机制来代替工作量证明，并保护数据的完整性。

第一种机制称为“自加密”。存储在网络中的任何数据在发送出去之前由客户端自动加密。也就是说任何运行保管库节点（Valut，译者注：类似比特币网络的挖矿节点）的人都无法了解其储存的具体数据，因为只有数据的所有者才可以对该数据进行解密。这就使得创建包含恶意数据的另外一个网络并欺骗用户参与该假网络非常困难。

第二种机制是“链式邻组共识”。当数据发送到网络或从网络请求获取时，它必须在到达存储数据的最终位置之前通过一系列的节点和检查。这就是说，传输需要保存的数据的节点只是网络中节点链的一部分，而不是该数据的原始所有者。这种链接机制类似于TOR网络，因而需要保存的数据可以完全匿名。此外，所有数据都是可互换的，从链上的保管库节点或其他节点的角度看，没有任何数据会比其他数据更重要或不重要。这也使得非常难以隔离网络上某部分有特殊意义的数据子集，来用于创建假的伪造网络。

通过在客户端加密数据，再通过请求路径连接该数据从而保证完整性和一致性，创建客户端仍能接受的伪造网络变得非常困难。这就使得检测网络的伪造版本变得很简单，就像工作量证明使得检测假区块链非常简单。

“自加密”和“邻组共识”正是SAFE网络可以保证完整性，而不使用工作量证明的原因。

更多内容可以查看[“自加密”](https://safenetwork.wiki/en/Security_-_Self_encryption)
这里可以查看关于[链式邻组共识](https://github.com/maidsafe/safe_vault/blob/87c64d6c74a403629b48d34bee9508706ca083b9/README.md#flows)以及[保管库节点工作方式](https://safenetwork.wiki/en/Vaults_(How_it_works)#Group_Consensus)

[返回目录](#blockchain_toc)

### 双重花费问题预防

比特币通常被称为解决了“双重花费问题”（简称，双花），也就是说比特币实现了数据的原子性，一致性，隔离性和耐用性（ACID）的同时，它又是一个分布式，去中心化、及不基于信任的网络。这在计算机科学和现实世界的应用中都意义巨大，因为这就是意味着已经花掉的钱可以确保已经花掉。或者对于数据来说，当数据被更改后，可以确保它被更改状态。

SAFE网络也有一个类似比特币的代币，称为Safecoin。比特币的交易数据是不断添加到区块链。而safecoin的所有权数据则是在SAFE网络上不断更新。SAFE网络是如何确保在SAFE网络上使用的代币不受到双花的攻击呢？与比特币的实现相比又是如何呢？

让我们先建立对比特币和双花的一个基本理解。当接收到比特币时，不会被双花的信心取决于交易有多少个确认。双花在比特币上是可能的，只是非常难以做到。花钱及可替代 (Replace-by-fee) 使得双花的时间窗口更大且执行更简单。并且，比特币的双花可以被认为是关于对交易信心概率的高低，而无法绝对确定交易最终性。

而这正是SAFE网络相比特币的最大优势之一，即交易速度非常快，而且一旦交易完成，最终性也确定了。这是如何做到的呢？要了解，我们必须先看看比特币与 Safecoin 在网络上的数据表示方式的不同。

在比特币区块链上，比特币是分组的输出，并不作为分开的数据实体存在。例如，挖矿的奖励目前为每个区块25个 BTC（译者注：现在已经减半成为每个区块 12.5个 BTC），但这25个 BTC 是在单个交易中表示的，即25个币，1份数据。

不同的是，每个 Safecoin 都是一个分散的数据片，在网络上有自己的位置（就像 SAFE网络上的普通的数据）。25个 safecoin 就是在 SAFE网络上的25份不同数据。

实现代币的这种本质区别就是 Safecoin 如何实现快速交易，并具有如此高的交易最终性的原因。Safecoin 的交易机制与比特币是截然不同的。

Safecoin 是一个特殊的数据包（称为结构化数据），其中包含当前所有者和前一个所有者的详细信息。为了转让该币的所有权，当前所有者必须证明其所有权（类似于比特币交易中的签名）。如果他拥有该币，他可以将代币当前所有者的数据更改为新的所有者。一个 Safecoin 的“当前所有者”就像一个比特币交易的 utxo。 “先前所有者”就像生成 utxo 的输入。Safecoin 的所有权只可以追溯到上一个所有者，而比特币的所有权可以一直追溯到代币的创建，其中可能包括数以百计的所有者。

传输 safecoin 是SAFE网络上的单一原子数据事件。一旦完成，它将保持这种状态，直到新的所有者决定更改它。也没有办法使其回滚，而不像比特币那样可以回滚到mempool甚至是以前的孤块。

比较完成一笔交易的成本。在比特币中，交易的成本是该交易相对于整个块的大小乘以生成块的工作量证明的成本。在 safecoin 中，该成本是获取数据所需的资源（邻组节点必须达成共识，再存储修改内容）乘以所花费的代币数量。与比特币交易相比，Safecoin 交易是非常高效的，因为邻组共识机制比生成工作量证明要便宜和快速得多。

[返回目录](#blockchain_toc)